# =======================
# üß± System Utilities
# =======================
alias ibrew='arch -x86_64 /usr/local/bin/brew'
alias mbrew='arch -arm64e $MBREW_HOME/brew'
alias jsc=/System/Library/Frameworks/JavaScriptCore.framework/Versions/Current/Helpers/jsc
alias brew_python="/usr/local/opt/python@3.10/bin/python3.10"
alias py3=brew_python
alias va="vi ~/.alias"
alias sa="source ~/.alias"
alias ve="vi ~/.env"
alias se="source ~/.env"
alias sz="source ~/.zshrc"
alias uvruntrace="RUST_LOG=uv=trace uv run -v "
alias llm="/Users/kosiew/GitHub/llm/.venv/bin/llm"
alias strip-tags="/Users/kosiew/GitHub/strip-tags/.venv/bin/strip-tags" 
alias ttok="/Users/kosiew/GitHub/ttok/.venv/bin/ttok"


# Path to the central python alias CLI
ALIAS_PY="$HOME/GitHub/python-scripts/alias.py"

# Helper to run a subcommand of alias.py with arguments. Keeps wrappers DRY.
run_alias_py() {
  if [ -x "$ALIAS_PY" ] || [ -f "$ALIAS_PY" ]; then
  /usr/local/bin/python "$ALIAS_PY" "$@"
  else
    echo "‚ùå alias CLI not found at $ALIAS_PY" >&2
    return 1
  fi
}

encode_and_copy() {
  run_alias_py encode_and_copy "$1"
}

prettier_toggle() {
  run_alias_py prettier_toggle
}

chatmodes_copy() {
  run_alias_py chatmodes_copy "$1"
}
 

fselect() {
  mkdir -p ~/tmp
  local file action
  local initial_query="$1"

  file=$(fd --type f --hidden --no-ignore \
            --exclude .git/logs \
            --exclude .git/refs \
			--exclude node_modules \
			--exclude .DS_Store \
			--exclude __pycache__ \
        | fzf --height=40% --border \
              --preview 'bat --style=numbers --color=always {} || cat {}' \
              --query="$initial_query") || return

  echo "$file" | tee ~/tmp/.fzf_file >(pbcopy) >/dev/null

  action=$(printf "open\nedit (vi)\nedit (nano)\nedit (code)\ndelete\nmove\nrename\necho path\ncancel" | \
    fzf --prompt="Choose action for $(basename "$file"): ") || return

  case "$action" in
    open)
      open "$file"
      ;;
    "edit (vi)")
      mvim -c "syntax off" "$file"
      ;;
    "edit (nano)")
      nano "$file"
      ;;
    "edit (code)")
      code "$file"
      ;;
    delete)
      rm "$file"
      ;;
    move)
      local current_dir dest
      current_dir=$(dirname "$file")
      dest="$current_dir"
      echo "Move to (destination directory):"
      vared dest

      if [ -z "$dest" ]; then
        echo "‚ö†Ô∏è Move cancelled: no destination provided."
      elif [ "$dest" = "$current_dir" ]; then
        echo "‚ÑπÔ∏è Destination is the same as current. No move performed."
      else
        mkdir -p "$dest"
        mv "$file" "$dest/"
        echo "‚úÖ Moved to $dest/"
      fi
      ;;
    rename)
      local current_name newname
      current_name=$(basename "$file")
      newname="$current_name"
      echo "Rename to (new filename):"
      vared newname

      if [ -z "$newname" ]; then
        echo "‚ö†Ô∏è Rename cancelled: no name provided."
      elif [ "$newname" = "$current_name" ]; then
        echo "‚ÑπÔ∏è Same name entered. No rename performed."
      else
        mv "$file" "$(dirname "$file")/$newname"
        echo "‚úÖ Renamed to $newname"
      fi
      ;;
    "echo path")
      echo "$file"
      ;;
    cancel)
      echo "Action cancelled."
      ;;
    *)
      echo "Unknown action: $action"
      ;;
  esac
}



chezcrypt() {
  run_alias_py chezcrypt "$@"
}



chezupdate() {
  run_alias_py chezupdate "$@"
}



chezadd() {
  run_alias_py chezadd "$@"
}




chezsync() {
  run_alias_py chezsync "$@"
}

off() {
  echo "üóÇÔ∏è Running chezsync before shutdown..."
  chezsync || { echo "‚ùå chezsync failed. Aborting shutdown."; return 1; }

  echo -n "üîí Proceed to shut down your Mac? [y/N] "
  read confirm
  if [[ "$confirm" =~ ^[Yy]$ ]]; then

    echo "üçé Initiating graceful macOS shutdown..."
    osascript -e 'tell application "System Events" to shut down'
  else
    echo "‚ùå Shutdown cancelled."
  fi
}
      

cdiff() {
  run_alias_py cdiff "$@"
}
 
 
clean_old_zcompdump() {
  run_alias_py clean_old_zcompdump "$@"
}

# ====================
# üß† General Tools
# ====================
alias nyd="npx prisma migrate dev && yd"
alias nh="npx hardhat"

copyfromurl() {
  run_alias_py copyfromurl "$@"
}
 

# ====================
# üßπ Yarn & JS Tooling
# ====================
# alias y="yarn"
# alias yt="y typecheck"
# alias ytest="y test:fast:watch"
# alias pp="y prettier:write && y eslint . --fix --ext .js,.jsx,.ts,.tsx && g st"
# alias gpp="yt && pp"
# alias yac="y allchecks"
# alias yd="y && y dev"
# alias ydf="y && NODE_ENV=development y vite --force"
# alias yptt="y playwright test --trace=on "
# alias yptc="y playwright test --trace=on --project=chromium "
# alias yptf="y playwright test --trace=on --project=firefox "
# alias yptr="y playwright test --trace=on --workers=5 --repeat-each=5 "
# alias pyptt="PWDEBUG=1 yptt"
# alias pyptc="PWDEBUG=1 yptc"
# alias cypt="CI=true yptt --project=firefox --project=chromium --workers=10 " 

# =======================
# üìù Text Editors & Notes
# =======================
alias vim=mvim
alias mvi=mvim
alias vi=mvim
alias journal="mvim $JOURNAL"
alias weeknotes="mvim $WEEK_NOTES"
alias kfm="mvim $KFM"
alias kfm_history="mvim $KFM_HISTORY"
alias boo="mvim $BOO"
alias boo_history="mvim $BOO_HISTORY"
alias inotes="mvim $INVESTMENT_JOURNAL"
alias scrap="mvim $SCRAP"
# alias history="mvim $HISTORY"
alias tickets="mvim $CLOUD/A8C/KeyboardMaestro/08_Interactions.txt"
alias links="mvim $CLOUD/A8C/KeyboardMaestro/09_TodoLinks.txt"
alias watches="open ~/myonedrive/Watches/watches.xlsm"


# =======================
# üåç Network & Connectivity
# =======================
alias vpn_check="dig +short -x `curl -s 'https://en.wordpress.com/whatismyip?'`"
alias ping8="ping 8.8.8.8"
alias updchrome="mbrew cask upgrade chromedriver"
alias wifi_reset="networksetup -setairportpower Wi-Fi off && networksetup -setairportpower Wi-Fi on"


# =======================
# üîó Web & Browsers
# =======================
alias firefox="/Applications/Firefox.app/Contents/MacOS/firefox "
alias firefoxhl="firefox -no-remote  -P Headless -headless "
alias chrome="/Applications/Google\ Chrome.app/Contents/MacOS/Google\ Chrome"
alias chromehl="chrome --headless --dump-dom "
alias upext='cd ~/wp-local-docker-sites/wpstore101-test/wordpress/wp-content/wc-prods && sh upext.sh && cd ~'



# =======================
# üíª Tmux
# =======================
alias tmux-rename="tmux rename-session -t \$(tmux display-message -p '#S')"

tmux-switch() {
  local session
  session=$(tmux list-sessions -F "#S" | fzf --prompt="Select tmux session: ")
  if [ -n "$session" ]; then
    if [ -z "$TMUX" ]; then
      tmux attach -t "$session"
    else
      tmux switch-client -t "$session"
    fi
  fi
}  


tmux-new() {
  if [ -z "$1" ]; then
    echo "Usage: tmux-new <session-name>"
    return 1
  fi

  if tmux has-session -t "$1" 2>/dev/null; then
    echo "Session '$1' already exists. Attaching..."
    tmux attach -t "$1"
  else
    tmux new-session -s "$1"
  fi
}

tmux-kill-unattached() {
  tmux list-sessions | grep -v '(attached)' | cut -d: -f1 | while read -r session; do
    echo "Killing session: $session"
    tmux kill-session -t "$session"
  done
}

update_tmux_window_name() {
  if [[ -n "$TMUX" ]]; then
    local folder_name
    folder_name=$(basename "$PWD")
    printf "\033]2;%s\033\\" "$folder_name"
  fi
}

# Run it on every directory change
precmd() { update_tmux_window_name }

# =======================
# üßëüíª Git & Branching
# =======================
alias g=/opt/homebrew/bin/git
# To retrieve the description of the currently checked-out Git branch 
alias gbd='BRANCH="$(git symbolic-ref --short HEAD)" && DESCRIPTION_PROPERTY="branch.${BRANCH}.description" && git config --get "$DESCRIPTION_PROPERTY"'
# pretty-print branch information using git bi 
alias gbi="git bi | column -ts'|'"
alias glo="git log --since=yesterday.midnight --oneline --graph --color=always --pretty=format:'%C(auto)%h%d %s' | perl -pe 's/^((?:(?!m).)* )/sprintf(\"%3s\", \$.) . \"* \"/e'"
alias gmp="git checkout main && git pull && git co -"
alias gmm="git merge main"
alias gpatch="git diff > wip.patch && git checkout ."
alias gapplypatch="git apply < wip.patch"
# back to how it was last commit 
alias grestore="git restore --staged . && git restore . && git clean -fd"
alias gbinfo="git branch --sort=-committerdate --format='%(HEAD)%(color:yellow)%(refname:short)|%(color:bold green)%(committerdate:relative)|%(color:blue)%(subject)|%(color:magenta)%(authorname)%(color:reset)' --color=always | column -ts'|'"

alias gco="git checkout \"\$(git branch | sed 's/^..//' | fzf)\""
# g sync main
# alias gsm="git checkout main && gsync && g cob"



gsm() {
  run_alias_py gsm "$@"
}

branches() {
  branch=""
  branches=`git branch --list`
  red='\033[0;31m'
  yellow='\033[0;33m'
  green='\033[0;32m'
  clear='\033[0m'
  while read -r branch; do
    clean_branch_name=${branch//\*\ /}
    description=`git config branch.$clean_branch_name.description`
    printf "%-15s %s\n ${yellow}${branch}${clear}    ${green}$description${clear}"
  done <<< "$branches"
}


# git delete branch local, remote

gdb() {
  run_alias_py gdb "$@"
}

 

# git diff --name-only
# gdn() {
#   local branch="${1:-main}"
#   git diff --name-only "$branch" | vi -
# }
gdn() {
  run_alias_py gdn "$@"
}

 
gcom() {
  run_alias_py gcom "$@"
}


gsync() {
  run_alias_py gsync "$@"
}

# Squash commit range (c1^..c2) into ONE commit using _gcommit_with_message,
# then apply the squashed history back to a target branch in one go.
#
# Usage:
#   gsquash <c1> <c2> [-t <target-branch>] [-F] [-k] [-- <message...>]
#
# Flags:
#   -t, --to         Target branch to update (default: current branch)
#   -F, --force-push Force-push target branch to its upstream after rewrite
#   -k, --keep-temp  Keep the temporary squash branch (default: delete it)
gsquash() {
  run_alias_py gsquash "$@"
}


gggrbi() {
  run_alias_py gggrbi "$@"
}


gacommit() {
  run_alias_py gacommit "$@"
}
 
#auto commit message for staged files 

_gcommit_with_message() {
  run_alias_py gcommit "$@"
}


gcommit() {
  run_alias_py gcommit "$@"
}

# copy HEAD commit hash
gcopyhash() {
  run_alias_py gcopyhash "$@"
}
 
gcopybranch() {
  run_alias_py gcopybranch "$@"
}

# create branch test with commit point


gtest() {
  run_alias_py gtest "$@"
}


 
gfilecommit() {
  run_alias_py gfilecommit "$@"
}

# git commit unstaged files individually
gfcommit() {
  run_alias_py gfcommit "$@"
}
 

gsplit() {
  run_alias_py gsplit "$@"
}


# Apply a patch from the clipboard (handles heredoc-wrapped commands too)
# Build clean patch: drop code fences, start at first 'diff --git', normalize CRLF
gappdiff() {
  run_alias_py gappdiff "$@"
}


grevdiff() {
  run_alias_py grevdiff "$@"
}

 

gadded() {
  run_alias_py gadded "$1"
}


# Rebase a range and add Signed-off-by to each commit.
# Usage:
#   gsign <upstream|range> [--autosquash] [--rebase-merges]
#
# Examples:
#   gsign main            # rebase commits since main (i.e., main..HEAD)
#   gsign main..HEAD      # same as above
#   gsign abc123..def456  # rebase commits in that explicit range
#   gsign main --autosquash
#   gsign main --rebase-merges
gsign() {
  run_alias_py gsign "$@"
}

# find commit hash of pr number
gprhash() {
  run_alias_py gprhash "$1"
}

# git diff
gdiff() {
  run_alias_py gdiff "$@"
}


gs() {
  run_alias_py gs "$@"
}

grmuntracked() {
  run_alias_py grmuntracked "$@"
}
 

# git new branch

gnb() {
  if [ $# -ne 1 ]; then
    echo "Usage: gnb <new-branch-name>"
    return 1
  fi

  local branch="$1"

  # If branch exists locally, delete it
  if git show-ref --verify --quiet "refs/heads/$branch"; then
    echo "üóëÔ∏è Deleting existing branch '$branch'..."
    git branch -D "$branch" || {
      echo "‚ùå Failed to delete branch '$branch'."
      return 1
    }
  fi

  git checkout -b "$branch" && \
  git checkout dev -- AGENTS.md && \
  git add AGENTS.md && \
  git commit -m "UNPICK added AGENTS.md"
}
 

# go git manager
ggm() {
  /Users/kosiew/GitHub/go_git_manager/git_branch_manager "$@"
}


# =======================
# üêç Python & Virtual Environments
# =======================


pipinstall() {
  if [ $# -eq 0 ]; then
    echo "Please provide at least one package name."
    return 1
  fi
  for package in "$@"; do
    pip install -U "$package" > /dev/null
    if [ $? -eq 0 ]; then
      echo "Installation of $package successful."
    else
      echo "Installation of $package failed."
    fi
  done
}

pipuninstall() {
  if [ $# -eq 0 ]; then
    echo "Please provide at least one package name."
    return 1
  fi
  for package in "$@"; do
    pip uninstall -y "$package" > /dev/null
    if [ $? -eq 0 ]; then
      echo "Uninstallation of $package successful."
    else
      echo "Uninstallation of $package failed."
    fi
  done
}

pythoninfo() {
  echo "Python Version:"
  python --version
  echo -e "
Installed Packages:"
  pip freeze
}

create_venv() {
  VENV_DIR=".venv"
  if [ ! -d "$VENV_DIR" ]; then
    echo "üõ†Ô∏è Creating virtual environment..."
    python -m venv "$VENV_DIR"
  else
    echo "‚úÖ Virtual environment already exists."
  fi
}

activate_venv() {
  VENV_DIR=".venv"
  if [ -f "$VENV_DIR/bin/activate" ]; then
    echo "‚ö° Activating virtual environment..."
    source "$VENV_DIR/bin/activate"
  else
    echo "‚ùå No virtual environment found. Run create_venv first."
    return 1
  fi
}

upgrade_pip() {
  echo "üì¶ Upgrading pip..."
  pip install --upgrade pip
}

pip_install_requirements() {
  if [ -f "requirements.txt" ]; then
    echo "üìÑ Installing dependencies from requirements.txt..."
    pip install -r requirements.txt
  else
    echo "‚ùå requirements.txt not found!"
    return 1
  fi
}

venvsetup() {
  create_venv
  activate_venv
  upgrade_pip
  pip_install_requirements
  echo "üéâ Dev environment is ready and activated!"
}
 
z_activate_venv() {
  if [ -d "$VENV_PATH" ]; then
    echo "Activating virtual environment at $VENV_PATH"
    source "$VENV_PATH/bin/activate"
  else
    echo "VENV_PATH not found"
    return 1
  fi
}

z_mkvenv() {
  if [ -z "$1" ]; then
    echo "Please provide a name for the virtual environment."
    return 1
  fi
  VENV_NAME="$1"
  VENV_PATH="$VENV_ROOT/$VENV_NAME"
  ACTIVATE_SCRIPT="$(pwd)/activate_venv.sh"
  PYTHON_VERSION=${2:-3.12}
  PYTHON_PATH="/opt/homebrew/bin/python${PYTHON_VERSION}"
  if [ ! -x "$PYTHON_PATH" ]; then
    echo "Python version $PYTHON_VERSION not found at $PYTHON_PATH."
    return 1
  fi
  "$PYTHON_PATH" -m venv "$VENV_PATH"
  if [ $? -eq 0 ]; then
    echo "Virtual environment '$VENV_NAME' created at $VENV_PATH using Python $PYTHON_VERSION."
    source "$VENV_PATH/bin/activate"
    python --version
    deactivate
    echo "#!/bin/zsh
VENV_PATH=\"$VENV_PATH\" activate_venv" > "$ACTIVATE_SCRIPT"
    chmod +x "$ACTIVATE_SCRIPT"
    echo "Activation script created at $ACTIVATE_SCRIPT."
  else
    echo "Failed to create virtual environment '$VENV_NAME'."
  fi
}

z_activatevenv() {
  if [ -z "$1" ]; then
    echo "Please provide the name of the virtual environment."
    return 1
  fi
  VENV_PATH="$VENV_ROOT/$1/bin/activate"
  if [ -f "$VENV_PATH" ]; then
    source "$VENV_PATH"
    echo "Activated virtual environment: $1"
  else
    echo "Virtual environment '$1' not found."
  fi
}

z_rmvenv() {
  if [ -z "$1" ]; then
    echo "Please provide the name of the virtual environment to remove."
    return 1
  fi
  VENV_NAME="$1"
  VENV_PATH="$VENV_ROOT/$VENV_NAME"
  if [ -d "$VENV_PATH" ]; then
    rm -rf "$VENV_PATH"
    echo "Virtual environment '$VENV_NAME' removed."
  else
    echo "Virtual environment '$VENV_NAME' not found."
  fi
}

z_cdvenv() {
  if [ -z "$VIRTUAL_ENV" ]; then
    echo "No virtual environment is currently activated."
    return 1
  fi
  cd "$VIRTUAL_ENV" || return 1
  echo "Changed directory to the virtual environment: $VIRTUAL_ENV"
}

z_lsvenv() {
  VENV_DIR="$VENV_ROOT"
  if [ ! -d "$VENV_DIR" ]; then
    echo "Virtual environment directory $VENV_DIR does not exist."
    return 1
  fi
  echo "Listing virtual environments in $VENV_DIR:"
  ls -1 "$VENV_DIR"
}


# ====================
# üõ†Ô∏è Misc Tools
# ====================
alias files-to-prompt="/Users/kosiew/GitHub/files-to-prompt/.venv/bin/files-to-prompt"
alias sklearn_label="/Users/kosiew/GitHub/gmail-ai-labeller/.venv/bin/python /Users/kosiew/GitHub/gmail-ai-labeller/gmail_labeller.py sklearn-label"

alias rgrs="rg -g '*.rs' -g '*.py'" 

# ====================
# üß™ Python Utilities
# ====================
alias td="python3 $PYTHON_SOURCE/todo/todo.py "
alias bw="python3 $PYTHON_SOURCE/bv_wordpress.py "
alias ba="python3 $PYTHON_SOURCE/bv_automattic.py "
alias pulse="python3 $PYTHON_SOURCE/bv_speedtest.py pulse"
alias pytest3="python3 -m pytest"
alias open_urls="python3 $PYTHON_SOURCE/open_urls.py "
alias say="python3 say.py say " 

# ====================
# üêò Postgres
# ====================
alias psqlstart="mbrew services start postgresql@14"
alias psqlstop="mbrew services stop postgresql@14" 

# ====================
# üß† Dev Navigation
# ====================
alias zp="cd ~/Cloud/Source/python3"
alias zap="cd /Users/kosiew/Library/Application\ Support/Alfred/Alfred.alfredpreferences/workflows/"
#alias zap = "cd /Users/kosiew/Library/CloudStorage/OneDrive-Personal/A8C/Alfred/Alfred.alfredpreferences/workflows/" 
alias lrt="eza -l -snew "

# ====================
# üß† Editor
# ====================
alias icode="code-insiders"

# ====================
# üó£Ô∏è Audio / Whisper
# ====================
alias whisper="/Users/kosiew/github/whisper.cpp/main -m models/ggml-large-v2.bin"

# ====================
# üåç Docker UI
# ====================
alias openwebui="docker run -d -p 3000:8080 --add-host=host.docker.internal:host-gateway -v open-webui:/app/backend/data --name open-webui --restart always ghcr.io/open-webui/open-webui:main"

mobydev() {
  docker run --rm -it --privileged \
    --name moby-dev \
    -e BUILDFLAGS \
    -e DOCKER_BUILD_PKGS \
    -e DOCKER_DEBUG \
    -e DOCKER_EXPERIMENTAL \
    -e DOCKER_GITCOMMIT \
    -e DOCKER_GRAPHDRIVER=vfs \
    -v "$(pwd):/go/src/github.com/docker/docker" \
    docker-dev bash
}
 

# =======================
# ü¶Ä Rust / Cargo Tools
# =======================
alias c=/Users/kosiew/.cargo/bin/cargo
alias find_rust_import="python /Users/kosiew/GitHub/python-scripts/rust_tools.py find-rust-imports "
alias craft_test="python /Users/kosiew/GitHub/python-scripts/rust_tools.py craft-test "
alias fri=find_rust_import


rust_clippy() {
  local script="ci/scripts/rust_clippy.sh"

  if [ -x "$script" ]; then
    echo "üëã running datafusion rust_clippy"
    "$script" 2>&1 | vi -
  else
    echo "‚ö†Ô∏è $script not found or not executable."
  fi
}

 
# cargo check
ccheck() {
  local mode=""
  local lines=""
  local project=""
  local args=()

  while [[ $# -gt 0 ]]; do
    case "$1" in
      -h)
        mode="head"
        lines="$2"
        shift 2
        ;;
      -t)
        mode="tail"
        lines="$2"
        shift 2
        ;;
      -p)
        project="$2"
        shift 2
        ;;
      *)
        args+=("$1")
        shift
        ;;
    esac
  done

  local cmd="c check"
  if [[ -n "$project" ]]; then
    cmd+=" -p $project"
  fi

  if [[ -n "$mode" && -n "$lines" ]]; then
    eval "$cmd" 2>&1 | "$mode" -n "$lines" | vi -
  else
    eval "$cmd" 2>&1 | vi -
  fi
}




crun() {
  local mode=""
  local lines=""
  local verbose=""
  local args=()

  while [[ $# -gt 0 ]]; do
    case "$1" in
      -h) mode="head"; lines="$2"; shift 2;;
      -t) mode="tail"; lines="$2"; shift 2;;
      -v) verbose="true"; shift;;
      --) shift; args+=("--" "$@"); break;;
      *)  args+=("$1"); shift;;
    esac
  done

  # default to quiet unless -v given
  local cmd=(cargo run)
  [[ -z "$verbose" ]] && cmd+=("-q")
  cmd+=("${args[@]}")

  if [[ -n "$verbose" ]]; then
    if [[ -n "$mode" && -n "$lines" ]]; then
      "${cmd[@]}" 2>&1 | "$mode" -n "$lines"
    else
      "${cmd[@]}" 2>&1
    fi
  else
    if [[ -n "$mode" && -n "$lines" ]]; then
      "${cmd[@]}" 2>&1 | "$mode" -n "$lines" | vim -
    else
      "${cmd[@]}" 2>&1 | vim -
    fi
  fi
}



# cargo test log

ctest() {
  local mode=""
  local lines=""
  local verbose=""
  local args=()
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -h)
        mode="head"; lines="$2"; shift 2;;
      -t)
        mode="tail"; lines="$2"; shift 2;;
      -v)
        verbose="true"; shift;;
      *)
        args+=("$1"); shift;;
    esac
  done

  # default to -q unless verbose is requested
  local cargo_cmd=("cargo" "test")
  if [[ -z "$verbose" ]]; then
    cargo_cmd+=("-q")
  fi
  cargo_cmd+=("${args[@]}")

  if [[ -n "$verbose" ]]; then
    if [[ -n "$mode" && -n "$lines" ]]; then
      "${cargo_cmd[@]}" 2>&1 | $mode -n "$lines"
    else
      "${cargo_cmd[@]}" 2>&1
    fi
  else
    if [[ -n "$mode" && -n "$lines" ]]; then
      "${cargo_cmd[@]}" 2>&1 | $mode -n "$lines" | vi -
    else
      "${cargo_cmd[@]}" 2>&1 | vi -
    fi
  fi
}


# =======================
# ü§ñ LLM Tools
# =======================
# vi models set up for llm
alias llm_models="vi /Users/kosiew/Library/Application\ Support/io.datasette.llm/extra-openai-models.yaml"
alias llm_aliases="vi /Users/kosiew/Library/Application Support/io.datasette.llm/aliases.json"


# Core helper to process an issue with a prompt and save to a file


_generate_filename() {
  local id="$1"
  local title_source="$2"
  local prefix="${3:-note}"

  local short_title
  short_title=$(llm -u -ef "$title_source" \
    "Generate a short, kebab-case filename-style title for this GitHub issue. Avoid punctuation. No more than 8 words." \
    | head -n1 | tr -cd '[:alnum:]-')

  if [[ -z "$short_title" ]]; then
    echo "‚ùå Error: Could not generate a short title." >&2
    return 1
  fi

  local timestamp
  timestamp=$(date +"%Y-%m-%d_%H-%M")
  echo ~/tmp/"${id}-${prefix}-${short_title}_${timestamp}.md"
}


_save_and_open_file() {
  local filepath="$1"
  local prompt="$2"
  local ef_arg="$3"

  echo "Saving output to $filepath..."
  if ! llm -u -ef "$ef_arg" "$prompt" > "$filepath"; then
    echo "‚ùå Error: Failed to generate summary content."
    rm -f "$filepath"
    return 1
  fi

  echo "Opening $filepath in vi..."
  vi -c "syntax off" "$filepath"
}

_process_issue() {
  local url="$1"
  local prompt="$2"
  local prefix="${3:-note}"

  echo "Extracting issue/PR number..."
  local issue_number
  issue_number=$(echo "$url" | awk -F'/' '{print $(NF)}')

  local filepath
  filepath=$(_generate_filename "$issue_number" "issue:$url" "$prefix") || return 1

  _save_and_open_file "$filepath" "$prompt" "issue:$url"
}

_process_clipboard_issue() {
  local prompt="$1"
  local prefix="${2:-clip}"

  echo "Generating short title from clipboard..."
  local short_title
  short_title=$(pbpaste | llm "Generate a short, kebab-case filename-style title for this GitHub issue. Avoid punctuation. No more than 8 words." \
    | head -n1 | tr -cd '[:alnum:]-')

  if [[ -z "$short_title" ]]; then
    echo "‚ùå Error: Could not generate a short title from clipboard."
    return 1
  fi

  local timestamp
  timestamp=$(date +"%Y-%m-%d_%H-%M")
  local filepath=~/tmp/"${prefix}-${short_title}_${timestamp}.md"

  echo "Saving output to $filepath..."
  if ! pbpaste | llm "$prompt" > "$filepath"; then
    echo "‚ùå Error: Failed to generate summary content."
    rm -f "$filepath"
    return 1
  fi

  echo "Opening $filepath in vi..."
  vi -c "syntax off" "$filepath"
}



icomment() {
  if [ $# -ne 1 ]; then
    echo "Usage: icomment <github-issue-url>"
    return 1
  fi
  _process_issue "$1" \
    "Add a well-thought-out comment to the issue. It should provide a new and helpful perspective, ideally grounded in the code or project direction. Keep it constructive and specific." \
    "icomment"
}

irespond() {
  if [ $# -ne 1 ]; then
    echo "Usage: irespond <github-issue-url>"
    return 1
  fi
  _process_issue "$1" \
    "Respond to the latest unanswered questions directed at @kosiew. Provide thoughtful, detailed, and technically sound arguments to move the discussion forward. Be respectful and concise." \
    "irespond"
}

isum() {
  if [ $# -ne 1 ]; then
    echo "Usage: isum <github-issue-url>"
    return 1
  fi
  _process_issue "$1" \
    "Summarize the issue with headings, bullet points, and add diagrams if they help clarify the concepts." \
    "isum"
}

# summarize issue in clipboard
isum_clip() {
  _process_clipboard_issue \
    "Summarize the issue with headings, bullet points, and add diagrams if they help clarify the concepts." \
    "isum_clip"
} 

ideep() {
  if [ $# -ne 1 ]; then
    echo "Usage: ideep <github-issue-url>"
    return 1
  fi
  _process_issue "$1" \
    "You are a senior open-source contributor and software engineer. 
    Given the GitHub issue linked, think deeply and suggest:
    - How one might investigate this issue
    - Multiple approaches to resolve it
    - Rank the approaches by feasibility and effectiveness
    - Provide brief rationale for the rankings
    Format the response with clear headings and bullet points." \
    "ideep"
}

icodex() {
  if [ $# -ne 1 ]; then
    echo "Usage: icodex <github-issue-url>"
    return 1
  fi
  _process_issue "$1" \
    "
You are a **senior open-source contributor and software engineer**. Given a GitHub issue, follow the instructions based on its type:
---
### **A. Feature or Improvement Request**
1. **Analyze** the issue and produce **multiple distinct solution approaches**.
2. For **each approach**, include:
   * **Title & Summary** ‚Äì A short, clear description of the strategy.
   * **Agent Instructions** ‚Äì Specific, executable steps for an AI coding agent (e.g., Codex) to implement the solution, including:
     * Identifying the files, directories, or modules to review.
     * How to evaluate extending existing modules vs. creating new ones.
     * Step-by-step implementation actions.
3. **Ranking** ‚Äì Order the approaches by **feasibility** and **effectiveness**.
4. **Formatting Requirements**:
   * Use a **Heading** for each approach.
   * Use **bullet points** or **code blocks** for agent instructions.
   * End with a **final ranked list** of approaches.
5. **Do not** include generic investigation steps or commentary‚Äîonly concrete, actionable guidance.
---
### **B. Bug Report**
Produce **direct instructions** for an AI coding agent (e.g., Codex) to:
1. **Confirm the bug** by:
   * Creating a **script or test** in the relevant file to reproduce the issue.
2. **Investigate** by:
   * Identifying the root cause.
3. **Fix** by:
   * Modifying the relevant code sections to resolve the root cause.
4. Focus solely on **specific, executable actions**‚Äîexclude vague steps or general debugging tips." \
    "icodex"
}


# gappdiff pr diff into a new branch
# get commit hash of diff
# get url of issue
# upload branch
# run iprfb to generate prompt
# paste prompt in codex

iprfb() {
  if [ $# -ne 2 ]; then
    echo "Usage:"
    echo "  iprfb <github-issue-url> <commit-hash>"
    echo "  iprfb \"<issue-summary>\" <commit-hash>"
    return 1
  fi

  local first="$1"
  local hash="$2"

  # Decide mode: URL vs provided summary
  local is_url=0
  if [[ "$first" =~ ^https?:// ]]; then
    is_url=1
  fi

  # Build step 1 text and optional injected summary block
  local summary_step
  local prefilled_summary=""
  if [ $is_url -eq 1 ]; then
    summary_step="1. **Summarize** the issue clearly and concisely (source: ${first})."
  else
    summary_step="1. **Use the provided issue summary** (do not re-summarize):"
    prefilled_summary=$'\n\n**Issue Summary (provided):**\n\n> '"${first//$'\n'/$'\n> '}"$'\n'
  fi

  # Generate a short title for logging / filenames (no network required)
  local short_title=""
  if command -v llm >/dev/null 2>&1; then
    short_title="$(printf '%s' "$first" | llm -s "Condense this into a 6‚Äì10 word review title (no punctuation). If it's a URL, derive the title from the issue context.")"
  fi
  if [ -z "$short_title" ]; then
    # Fallback: sanitize first arg to a compact title
    short_title="$(printf '%s' "$first" \
      | sed -E 's#https?://##; s#[^[:alnum:][:space:]-]##g; s/[[:space:]]+/ /g; s/^ +| +$//g' \
      | cut -c1-60)"
    [ -z "$short_title" ] && short_title="issue-review"
  fi

  # Compose the full prompt
  local prompt
  prompt=$(cat <<EOF
**Role:** You are a **senior open-source contributor and software engineer**.

**Task:** Given a GitHub issue and the associated codebase, produce a strategic and actionable review by following these steps:

${summary_step}
2. **Review the changes introduced in commit: ${hash}**
3. **Provide constructive and actionable feedback**, focusing on:

- **Consistency** ‚Äî Are the changes aligned with the repository's coding conventions and structure?
- **Redundancy** ‚Äî Do the changes introduce any code duplication that could be avoided or refactored?
- **Effectiveness** ‚Äî Do the changes fully and appropriately address the described issue?

Conclusion:
- Approve
- Approve with Suggestions (list specific follow-up actions)
- Request Changes (list specific blocking issues)

${prefilled_summary}
EOF
)

  # ---- Execution handoff ----
  if [ $is_url -eq 1 ] && typeset -f _process_issue >/dev/null 2>&1; then
    # URL mode uses your existing pipe that knows how to fetch/summarize
    _process_issue "$first" "$prompt" "iprfb:${short_title}"
    return $?
  fi

  # Summary mode (or fallback if no _process_issue)
  if command -v llm >/dev/null 2>&1; then
    printf '%s' "$prompt" | llm
  else
    # No llm available; print the prompt to stdout so you can pipe it
    printf '%s\n' "$prompt"
  fi
}



 
# generate codex Ask prompt 
# on how to address issue
icask() {
  if [ $# -lt 1 ]; then
    echo "Usage: icask <github-issue-url> [comment]"
    return 1
  fi

  local url="$1"
  shift
  local comment="$*"

  # Rephrase the optional comment if possible
  local rephrased=""
  if [ -n "$comment" ]; then
    if command -v llm >/dev/null 2>&1; then
      rephrased="$(printf '%s' "$comment" | llm -s "Rephrase this reviewer note in 1‚Äì2 concise, professional sentences. Keep key constraints; avoid first person; do not quote verbatim.")"
      # fallback if llm returns empty
      [ -z "$rephrased" ] && rephrased="$comment"
    else
      rephrased="$comment"
    fi
  fi

  # Build Step 1 line
  local summary_step
  if [ -n "$rephrased" ]; then
    summary_step="1. **Summarize** the issue clearly and concisely, incorporating this reviewer note (already rephrased): ${rephrased}"
  else
    summary_step="1. **Summarize** the issue clearly and concisely."
  fi

  # Compose the full prompt
  local prompt
  prompt=$(cat <<EOF
**Role:** You are a **senior open-source contributor and software engineer**.

**Task:** Given a GitHub issue and the associated codebase, produce a strategic and actionable review by following these steps:

${summary_step}
2. **Complete the following template**, which will be used as instructions for a coding agent (e.g., Codex) to act upon.

---

**Instruction Template**

## <Concise Description of the Issue>

**Steps:**

1. Review the repository to locate all areas relevant to the issue.
2. Determine whether the solution requires modifying existing code or extending the codebase.
3. Provide a high-level, detailed action plan for resolving the issue.

---

**Guidelines:**

* Do **not** generate code.
* Keep the commentary concise and strategic.
* Focus on problem analysis and solution direction rather than implementation details.
* Ensure the output is actionable for a coding agent without unnecessary narrative.
EOF
)

  _process_issue "$url" "$prompt" "icask"
}

# triage issue

ictriage() {
  if [ $# -ne 1 ]; then
    echo "Usage: ictriage <github-issue-url>"
    return 1
  fi

  local url="$1"

  description="1. **Describe** the issue clearly and concisely, with relevant information and code excerpt for investigation"

  # Compose the full prompt
  local prompt
  prompt=$(cat <<'EOF'
**Role:** You are a **senior open-source contributor and software engineer**.

**Task:** Given a GitHub issue and the associated codebase, perform **triage**.

**OUTPUT RULES (STRICT):**
- Produce **only** the sections shown below, in this exact order and formatting.
- After the Description, **reproduce the Steps block VERBATIM** (do not add, remove, or change words, bullets, or indentation).
- **Do not** add any extra sections such as "Analysis", "Determination", "Conclusion", or repository-specific sub-steps.
- Keep the Description concise.
- The first heading (## ...) should be the issue title or the primary error message.

---
**Output Format (reproduce exactly, except fill in the Description and heading):**

## <Issue Title or Primary Error Message>

**Description of issue:**
${description}

**Steps:**

1. Review the repository to locate all areas relevant to the issue.
2. Provide a high-level, detailed action plan for resolving the issue.
3. Determine whether the issue is
	- Bug to be fixed.
	- Feature to be implemented.
	- Update documentation to improve user experience.
	- Ask user for more information.
	- Other (with justification).
4. Provide a high-level, detailed action plan for resolving the issue.
---

EOF
)

  _process_issue "$url" "$prompt" "ictriage"
}



iask() {
  if [ $# -lt 2 ]; then
    echo "Usage: iask <github-issue-url> <question>"
    return 1
  fi
  local url="$1"
  shift
  local question="$*"
  _process_issue "$url" "$question" "iask"
}

imuse() {
  if [ $# -ne 1 ]; then
    echo "Usage: imuse <github-issue-url>"
    return 1
  fi
  _process_issue "$1" \
    "Reflect on this issue using clear headings, bullet points and illustrative diagrams to explore key aspects and relationships." \
    "imuse"
}

itry() {
  if [ "$1" = "--help" ]; then
    echo "Usage: itry [packages...]"
    echo "Example: itry llm sqlite-utils datasette"
    return 0
  fi
  local args=()
  for pkg in "$@"; do
    args+=("--with" "$pkg")
  done
  uvx "${args[@]}" --python 3.13 ipython
}

# =======================
# üß∞ Utility Functions
# =======================


findfile() {
  if [ -z "$1" ]; then
    echo "Usage: findfile <filename>"
    return 1
  fi

  echo "=== Searching in Current Directory ==="
  find . -iname "$1" 2>/dev/null
}

 

alias-find() {
  if [ -z "$1" ]; then
    echo "Usage: alias-find <search-term>"
    return 1
  fi

  echo "=== Aliases ==="
  alias | grep -i --color=always "$1"
  
  echo -e "\n=== Functions ==="
  # Search function names only (including hyphens in function names)
  declare -f | grep -E "^[a-zA-Z_][a-zA-Z0-9_-]* \(\)" | grep -i --color=always "$1"
}

 
check_filename() {
  if [ -z "$1" ]; then
    echo "Usage: $2 <filename>"
    return 1
  fi
}

get_commit_history() {
  local FILENAME=$1
  git log --oneline --pretty=format:"%h %s %Cgreen(%ar)" -- "$FILENAME"
}

git_log_copy() {
  check_filename "$1" "git_log_copy" || return 1
  get_commit_history "$1" | pbcopy
  echo "Commit history copied to clipboard."
}

git_diff_commits() {
  check_filename "$1" "git_diff_commits" || return 1
  local FILENAME=$1
  local COMMITS=($(pbpaste | awk '{print $1}'))
  for COMMIT in "${COMMITS[@]}"; do
    echo -e "
==== Diff for commit $COMMIT ===="
    git diff $COMMIT^! -- "$FILENAME"
  done
}

git_log_and_diff() {
  check_filename "$1" "git_log_and_diff" || return 1
  local FILENAME=$1
  git_log_copy "$FILENAME"
  git_diff_commits "$FILENAME"
}

files_to_prompt_command() {
  local search_term="$1"
  shift
  local rg_options=()
  local file_extensions=()
  for arg in "$@"; do
    if [[ "$arg" == -* ]]; then
      rg_options+=("$arg")
    else
      file_extensions+=("-g" "$arg")
    fi
  done
  if [ ${#file_extensions[@]} -eq 0 ]; then
    file_extensions=("-g" "*.rs" "-g" "*.py")
  fi
  local rg_cmd=(rg -l "${rg_options[@]}" "${file_extensions[@]}" "$search_term")
  echo "Running command: ${rg_cmd[*]}" >&2
  echo "" >&2
  local files=( $(${rg_cmd[*]}) )
  if [ ${#files[@]} -eq 0 ]; then
    echo "No files found."
    return 1
  fi
  command="files-to-prompt -c \
"
  for file in "${files[@]}"; do
    command+=" ${file} \
"
  done
  command+=" | vi -"
  echo "$command"
  echo "$command" | pbcopy
}
# =======================

# Function: Clean tmp files older than given days (default 30)
cleantmp() {
  DAYS=${1:-30}
  echo "Cleaning ~/tmp..."
  echo "Deleting files older than $DAYS days..."
  find ~/tmp -type f -mtime +$DAYS -print -delete

  echo "Deleting empty folders (excluding vim_swap and pycache)..."
  find ~/tmp \
    \( -path ~/tmp/vim_swap -o -path ~/tmp/pycache \) -prune -o \
    -type d -empty -print -delete

  echo "Cleanup complete ‚úÖ"
}

# Hook: Run cleantmp once a week with macOS notification
autoload -U add-zsh-hook

weekly_tmp_cleaner() {
  local stamp_file="$HOME/.cache/.cleantmp_last_run"
  local now=$(date +%s)
  local one_week=$((60 * 60 * 24 * 7))

  if [[ ! -f "$stamp_file" ]]; then
    mkdir -p "$(dirname "$stamp_file")"
    echo "$now" > "$stamp_file"
    cleantmp
    notify_cleantmp
    return
  fi

  local last_run=$(<"$stamp_file")
  if (( now - last_run >= one_week )); then
    cleantmp
    notify_cleantmp
    echo "$now" > "$stamp_file"
  fi
}

notify_cleantmp() {
  osascript -e 'display notification "Old files and empty folders cleaned from ~/tmp ‚úÖ" with title "Weekly Cleanup"'
}

add-zsh-hook precmd weekly_tmp_cleaner
